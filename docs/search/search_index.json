{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction The Policy Machine is an ever evolving reference implementation of the Next Generation Access Control (NGAC) standard. It started as a standalone Java program called Harmonia and has started it's next evolution to bring the NAGC standard to web based application through an administrative REST API. The goal of the Policy Machine is to demonstrate the power of NGAC and the benefits it can bring to the security industry. The Policy Machine projects currently being supported are: Policy Machine Core - The core functionality behind the Policy Machine is the NGAC graph and the algorithms used to query the access state of a graph. The Policy Machine Core project provides these components as a Java library and can easily be imported into any project using maven. Policy Machine (WIP) - The Policy Machine is our current environment for testing and demonstrating NGAC features. It incorporates every component of the NGAC functional architecture: Policy Enforcement Point (PEP), Policy Decision Point (PDP), Policy Information Point (PIP), Policy Access Point (PAP), and Event Processing Point (EPP).","title":"Introduction"},{"location":"#introduction","text":"The Policy Machine is an ever evolving reference implementation of the Next Generation Access Control (NGAC) standard. It started as a standalone Java program called Harmonia and has started it's next evolution to bring the NAGC standard to web based application through an administrative REST API. The goal of the Policy Machine is to demonstrate the power of NGAC and the benefits it can bring to the security industry. The Policy Machine projects currently being supported are: Policy Machine Core - The core functionality behind the Policy Machine is the NGAC graph and the algorithms used to query the access state of a graph. The Policy Machine Core project provides these components as a Java library and can easily be imported into any project using maven. Policy Machine (WIP) - The Policy Machine is our current environment for testing and demonstrating NGAC features. It incorporates every component of the NGAC functional architecture: Policy Enforcement Point (PEP), Policy Decision Point (PDP), Policy Information Point (PIP), Policy Access Point (PAP), and Event Processing Point (EPP).","title":"Introduction"},{"location":"contact/","text":"Contact Us David Ferraiolo - david.ferraiolo@nist.gov (Group Manager) Serban Gavrila - serban.gavrila@nist.gov (Developer) Gopi Katwala - gopi.katwala@nist.gov (Developer) Joshua Roberts - joshua.roberts@nist.gov (Developer)","title":"Contact Us"},{"location":"contact/#contact-us","text":"David Ferraiolo - david.ferraiolo@nist.gov (Group Manager) Serban Gavrila - serban.gavrila@nist.gov (Developer) Gopi Katwala - gopi.katwala@nist.gov (Developer) Joshua Roberts - joshua.roberts@nist.gov (Developer)","title":"Contact Us"},{"location":"pm-admin/","text":"PMAdmin Coming soon...","title":"PMAdmin"},{"location":"pm-admin/#pmadmin","text":"Coming soon...","title":"PMAdmin"},{"location":"pm-client/","text":"PM-Client Coming soon...","title":"PM-Client"},{"location":"pm-client/#pm-client","text":"Coming soon...","title":"PM-Client"},{"location":"policy-machine-core/","text":"policy-machine-core Introduction The purpose of Policy Machine Core project is to provide a bare bones library for NGAC. This library includes interfaces to interact with NGAC components,simple implementations of those interfaces, and algorithms to query the state of a graph. This is a great place to start experimenting with NGAC and different policy configurations. Installation Install using Maven Policy Machine Core uses JitPack to compile and build the artifact to import into projects. First, add jitpack as a repository <project> -- <repositories> <repository> <id>jitpack.io</id> <url>https://jitpack.io</url> </repository> </repositories> -- </project> Then, add the maven dependency <dependency> <groupId>com.github.PM-Master</groupId> <artifactId>policy-machine-core</artifactId> <version>1.0.0</version> </dependency> That's it, now the policy-machine-core library will be available for use in your project! Examples Serialization Graph Serialize a graph into a json string. Graph graph = new MemGraph(); --- String json = GraphSerializer.toJson(graph); Deserialize a json string to a graph. Graph graph = GraphSerializer.fromJson(new MemGraph(), json); Prohibitions Serialize a ProhibitionDAO into a json string. ProhibitionsDAO dao = new MemProhibitionsDAO(); --- String json = ProhibitionsSerializer.toJson(dao); Deserialize a json string to a ProhibitionsDAO. ProhibitionsDAO deDao = ProhibitionsSerializer.fromJson(new MemProhibitionsDAO(), json); Bank Teller Graph configuration summary Users: u1, u2 An object o1 Two policy classes: RBAC and Branches RBAC o1 is assigned to accounts u1 is a Teller that has read and write permissions on accounts u2 is an Auditor that has read permissions on accounts Branches u1 and u2 are both assigned to the Branch 1 user attribute o1 is assigned to the Branch 1 object attribute the Branch 1 user attribute has read and write permissions on the Branch 1 object attribute Access control state u1 can read and write o1 u2 can read o1 Code Wakthrough // 1. Create a new Graph instance. For this example, we'll use the `MemGraph` which is an in memory implementation of the Graph interface. Graph graph = new MemGraph(); // 2. Create the user nodes `u1` and `u2`. long user1ID = graph.createNode(new Node(rand.nextLong(), \"u1\", U, null)); long user2ID = graph.createNode(new Node(rand.nextLong(), \"u2\", U, null)); // 3. Create the object, `o1` that will be the target of the access queries. long objectID = graph.createNode(new Node(rand.nextLong(), \"o1\", O, null)); // 4. Create the `RBAC` policy class node. long rbacID = graph.createNode(new Node(rand.nextLong(), \"RBAC\", PC, null)); // 5. Create an object attribute for the `Accounts`. long accountsID = graph.createNode(new Node(rand.nextLong(), \"Accounts\", OA, null)); // 6. Create the `Teller` and `Auditor` user attributes. long tellerID = graph.createNode(new Node(rand.nextLong(), \"Teller\", UA, null)); long auditorID = graph.createNode(new Node(rand.nextLong(), \"Auditor\", UA, null)); // 7. Assign the `Accounts` object attribute to the `RBAC` policy class node. graph.assign(new Node(accountsID, OA), new Node(rbacID, PC)); // 8. Assign the object, `o1`, to the `Accounts` object attribute. graph.assign(new Node(objectID, O), new Node(accountsID, OA)); // 9. Assign `u1` to the `Teller` user attribute and `u2` to the `Auditor` user attribute. graph.assign(new Node(user1ID, U), new Node(tellerID, UA)); graph.assign(new Node(user2ID, U), new Node(auditorID, UA)); // 10. Create the associations for `Teller` and `Auditor` on `Account` in RBAC. `Teller` has read and write permissions, while `Auditor` just has read permissions. graph.associate(new Node(tellerID, UA), new Node(accountsID, OA), new HashSet<>(Arrays.asList(\"r\", \"w\"))); graph.associate(new Node(auditorID, UA), new Node(accountsID, OA), new HashSet<>(Arrays.asList(\"r\"))); // 11. Create the `Branches` policy class. long branchesID = graph.createNode(new Node(rand.nextLong(), \"branches\", PC, null)); // 12. Create an object attribute for `Branch 1`. long branch1OAID = graph.createNode(new Node(rand.nextLong(), \"branch 1\", OA, null)); // 13. Assign the branch 1 OA to the branches PC graph.assign(new Node(branch1OAID, OA), new Node(branchesID, PC)); // 14. Create the `Branch 1` user attribute long branches1UAID = graph.createNode(new Node(rand.nextLong(), \"branch 1\", UA, null)); // 15. Assign the object, `o1`, to the `Branch 1` object attribute graph.assign(new Node(objectID, O), new Node(branch1OAID, OA)); // 16. Assign the users, `u1` and `u2`, to the branch 1 user attribute graph.assign(new Node(user1ID, U), new Node(branches1UAID, UA)); graph.assign(new Node(user2ID, U), new Node(branches1UAID, UA)); // 17. Create an association between the `branch 1` user attribute and the `branch 1` object attribute. //This will give both users read and write on `o1` under the `branches` policy class. graph.associate(new Node(branches1UAID, UA), new Node(branch1OAID, OA), new HashSet<>(Arrays.asList(\"r\", \"w\"))); // 18. Test the configuration using the `PReviewDecider` implementation of the `Decider` interface. //The constructor for a `PReviewDecider` receives the graph we created and a list of prohibitions. //Since no prohibitions are used in this example, we'll pass null. Decider decider = new PReviewDecider(graph, null); // 19. Check that `u1` has read and write permissions on `o1`. Set<String> permissions = decider.listPermissions(user1ID, 0, objectID); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); // 20. Check that `u1` has read permissions on `o1`. permissions = decider.listPermissions(user2ID, 0, objectID); assertTrue(permissions.contains(\"r\")); Visualization Below is a visual representation of the graph created in the bank teller example. Employee Record Example configuration summary One policy class Users: bob, alice, charlie The objects are bob's and alice's name, salary, and ssn. All users are assigned to the Staff user attribute The Staff user attribute has read permissions on Public Info, which in this case is names. Charlie has the HR attribute HR has read and write permissions on Salaries and SSNs Bob and Alice have the Grp1Mgr and Grp2Mgr attributes, respectively Grp1Mgr and Grp2Mgr have read permissions on Grp1Salaries and Grp2Salaries, respectively Bob and Alice have read and write permissions on their name and ssn, and read permissions on their salaries. Access control state Alice can read and write her name and SSN, and read her salary, and the salaries of those in Group 2. Bob can read and write his name and SSN, and read his salary, and salaries of those in Group 1. Charlie can read and write all salaries and SSNs, and read all names. Graph graph = new MemGraph(); // create nodes // object attributes long salariesID = graph.createNode(new Node(rand.nextLong(), \"Salaries\", OA, null)); long ssnsID = graph.createNode(new Node(rand.nextLong(), \"SSNs\", OA, null)); long grp1SalariesID = graph.createNode(new Node(rand.nextLong(), \"Grp1 Salaries\", OA, null)); long grp2SalariesID = graph.createNode(new Node(rand.nextLong(), \"Grp2 Salaries\", OA, null)); long publicID = graph.createNode(new Node(rand.nextLong(), \"Public Info\", OA, null)); long bobRecID = graph.createNode(new Node(rand.nextLong(), \"Bob Record\", OA, null)); long bobRID = graph.createNode(new Node(rand.nextLong(), \"Bob r\", OA, null)); long bobRWID = graph.createNode(new Node(rand.nextLong(), \"Bob r/w\", OA, null)); long aliceRecID = graph.createNode(new Node(rand.nextLong(), \"Alice Record\", OA, null)); long aliceRID = graph.createNode(new Node(rand.nextLong(), \"Alice r\", OA, null)); long aliceRWID = graph.createNode(new Node(rand.nextLong(), \"Alice r/w\", OA, null)); // objects for bob's name, salary, and ssn long bobNameID = graph.createNode(new Node(rand.nextLong(), \"bob name\", O, null)); long bobSalaryID = graph.createNode(new Node(rand.nextLong(), \"bob salary\", O, null)); long bobSSNID = graph.createNode(new Node(rand.nextLong(), \"bob ssn\", O, null)); // objects for alice's name, salary, and ssn long aliceNameID = graph.createNode(new Node(rand.nextLong(), \"alice name\", O, null)); long aliceSalaryID = graph.createNode(new Node(rand.nextLong(), \"alice salary\", O, null)); long aliceSSNID = graph.createNode(new Node(rand.nextLong(), \"alice ssn\", O, null)); // user attributes long hrID = graph.createNode(new Node(rand.nextLong(), \"HR\", UA, null)); long grp1MgrID = graph.createNode(new Node(rand.nextLong(), \"Grp1Mgr\", UA, null)); long grp2MgrID = graph.createNode(new Node(rand.nextLong(), \"Grp2Mgr\", UA, null)); long staffID = graph.createNode(new Node(rand.nextLong(), \"Staff\", UA, null)); long bobUAID = graph.createNode(new Node(rand.nextLong(), \"Bob\", UA, null)); long aliceUAID = graph.createNode(new Node(rand.nextLong(), \"Alice\", UA, null)); // users long bobID = graph.createNode(new Node(rand.nextLong(), \"bob\", U, null)); long aliceID = graph.createNode(new Node(rand.nextLong(), \"alice\", U, null)); long charlieID = graph.createNode(new Node(rand.nextLong(), \"charlie\", U, null)); // policy class long pcID = graph.createNode(new Node(rand.nextLong(), \"Employee Records\", PC, null)); // assignments // assign users to user attributes graph.assign(new Node(charlieID, U), new Node(hrID, UA)); graph.assign(new Node(bobID, U), new Node(grp1MgrID, UA)); graph.assign(new Node(aliceID, U), new Node(grp2MgrID, UA)); graph.assign(new Node(charlieID, U), new Node(staffID, UA)); graph.assign(new Node(bobID, U), new Node(staffID, UA)); graph.assign(new Node(aliceID, U), new Node(staffID, UA)); graph.assign(new Node(bobID, U), new Node(bobUAID, UA)); graph.assign(new Node(aliceID, U), new Node(aliceUAID, UA)); // assign objects to object attributes // salary objects graph.assign(new Node(bobSalaryID, O), new Node(salariesID, OA)); graph.assign(new Node(bobSalaryID, O), new Node(grp1SalariesID, OA)); graph.assign(new Node(bobSalaryID, O), new Node(bobRID, OA)); graph.assign(new Node(aliceSalaryID, O), new Node(salariesID, OA)); graph.assign(new Node(aliceSalaryID, O), new Node(grp2SalariesID, OA)); graph.assign(new Node(aliceSalaryID, O), new Node(aliceRID, OA)); // ssn objects graph.assign(new Node(bobSSNID, O), new Node(ssnsID, OA)); graph.assign(new Node(bobSSNID, O), new Node(bobRWID, OA)); graph.assign(new Node(aliceSSNID, O), new Node(aliceID, OA)); graph.assign(new Node(aliceSSNID, O), new Node(aliceRWID, OA)); // name objects graph.assign(new Node(bobNameID, O), new Node(publicID, OA)); graph.assign(new Node(bobNameID, O), new Node(bobRWID, OA)); graph.assign(new Node(aliceNameID, O), new Node(publicID, OA)); graph.assign(new Node(aliceNameID, O), new Node(aliceRWID, OA)); // bob and alice r/w containers to their records graph.assign(new Node(bobRID, OA), new Node(bobRecID, OA)); graph.assign(new Node(bobRWID, OA), new Node(bobRecID, OA)); graph.assign(new Node(aliceRID, OA), new Node(aliceRecID, OA)); graph.assign(new Node(aliceRWID, OA), new Node(aliceRecID, OA)); // assign object attributes to policy classes graph.assign(new Node(salariesID, OA), new Node(pcID, PC)); graph.assign(new Node(ssnsID, OA), new Node(pcID, PC)); graph.assign(new Node(grp1SalariesID, OA), new Node(pcID, PC)); graph.assign(new Node(grp2SalariesID, OA), new Node(pcID, PC)); graph.assign(new Node(publicID, OA), new Node(pcID, PC)); graph.assign(new Node(bobRecID, OA), new Node(pcID, PC)); graph.assign(new Node(aliceRecID, OA), new Node(pcID, PC)); // associations Set<String> rw = new HashSet<>(Arrays.asList(\"r\", \"w\")); Set<String> r = new HashSet<>(Arrays.asList(\"r\")); graph.associate(new Node(hrID, UA), new Node(salariesID, OA), rw); graph.associate(new Node(hrID, UA), new Node(ssnsID, OA), rw); graph.associate(new Node(grp1MgrID, UA), new Node(grp1SalariesID, OA), r); graph.associate(new Node(grp2MgrID, UA), new Node(grp2SalariesID, OA), r); graph.associate(new Node(staffID, UA), new Node(publicID, OA), r); graph.associate(new Node(bobUAID, UA), new Node(bobRWID, OA), rw); graph.associate(new Node(bobUAID, UA), new Node(bobRID, OA), r); graph.associate(new Node(aliceUAID, UA), new Node(aliceRWID, OA), rw); graph.associate(new Node(aliceUAID, UA), new Node(aliceRID, OA), r); // test configuration // create a decider // not using prohibitions in this example, so null is passed Decider decider = new PReviewDecider(graph, null); // user: bob // target: 'bob ssn' // expected: [r, w] // actual: [r, w] Set<String> permissions = decider.listPermissions(bobID, 0, bobSSNID); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); // user: bob // target: 'bob ssn' // expected: [r] // actual: [r] permissions = decider.listPermissions(bobID, 0, bobSalaryID); assertTrue(permissions.contains(\"r\")); // user: bob // target: 'alice ssn' // expected: [] // actual: [] permissions = decider.listPermissions(bobID, 0, aliceSSNID); assertTrue(permissions.isEmpty()); // user: bob // target: 'alice salary' // expected: [] // actual: [] permissions = decider.listPermissions(bobID, 0, aliceSalaryID); assertTrue(permissions.isEmpty()); // user: bob // target: 'bob ssn' // expected: [r, w] // actual: [r, w] permissions = decider.listPermissions(aliceID, 0, aliceSSNID); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); // user: charlie // target: 'alice salary' // expected: [r, w] // actual: [r, w] permissions = decider.listPermissions(charlieID, 0, aliceSalaryID); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); Visualization Below is a visual representation of the graph created in the employee record example.","title":"policy-machine-core"},{"location":"policy-machine-core/#policy-machine-core","text":"","title":"policy-machine-core"},{"location":"policy-machine-core/#introduction","text":"The purpose of Policy Machine Core project is to provide a bare bones library for NGAC. This library includes interfaces to interact with NGAC components,simple implementations of those interfaces, and algorithms to query the state of a graph. This is a great place to start experimenting with NGAC and different policy configurations.","title":"Introduction"},{"location":"policy-machine-core/#installation","text":"","title":"Installation"},{"location":"policy-machine-core/#install-using-maven","text":"Policy Machine Core uses JitPack to compile and build the artifact to import into projects. First, add jitpack as a repository <project> -- <repositories> <repository> <id>jitpack.io</id> <url>https://jitpack.io</url> </repository> </repositories> -- </project> Then, add the maven dependency <dependency> <groupId>com.github.PM-Master</groupId> <artifactId>policy-machine-core</artifactId> <version>1.0.0</version> </dependency> That's it, now the policy-machine-core library will be available for use in your project!","title":"Install using Maven"},{"location":"policy-machine-core/#examples","text":"","title":"Examples"},{"location":"policy-machine-core/#serialization","text":"","title":"Serialization"},{"location":"policy-machine-core/#graph","text":"Serialize a graph into a json string. Graph graph = new MemGraph(); --- String json = GraphSerializer.toJson(graph); Deserialize a json string to a graph. Graph graph = GraphSerializer.fromJson(new MemGraph(), json);","title":"Graph"},{"location":"policy-machine-core/#prohibitions","text":"Serialize a ProhibitionDAO into a json string. ProhibitionsDAO dao = new MemProhibitionsDAO(); --- String json = ProhibitionsSerializer.toJson(dao); Deserialize a json string to a ProhibitionsDAO. ProhibitionsDAO deDao = ProhibitionsSerializer.fromJson(new MemProhibitionsDAO(), json);","title":"Prohibitions"},{"location":"policy-machine-core/#bank-teller","text":"","title":"Bank Teller"},{"location":"policy-machine-core/#graph-configuration-summary","text":"Users: u1, u2 An object o1 Two policy classes: RBAC and Branches RBAC o1 is assigned to accounts u1 is a Teller that has read and write permissions on accounts u2 is an Auditor that has read permissions on accounts Branches u1 and u2 are both assigned to the Branch 1 user attribute o1 is assigned to the Branch 1 object attribute the Branch 1 user attribute has read and write permissions on the Branch 1 object attribute","title":"Graph configuration summary"},{"location":"policy-machine-core/#access-control-state","text":"u1 can read and write o1 u2 can read o1","title":"Access control state"},{"location":"policy-machine-core/#code-wakthrough","text":"// 1. Create a new Graph instance. For this example, we'll use the `MemGraph` which is an in memory implementation of the Graph interface. Graph graph = new MemGraph(); // 2. Create the user nodes `u1` and `u2`. long user1ID = graph.createNode(new Node(rand.nextLong(), \"u1\", U, null)); long user2ID = graph.createNode(new Node(rand.nextLong(), \"u2\", U, null)); // 3. Create the object, `o1` that will be the target of the access queries. long objectID = graph.createNode(new Node(rand.nextLong(), \"o1\", O, null)); // 4. Create the `RBAC` policy class node. long rbacID = graph.createNode(new Node(rand.nextLong(), \"RBAC\", PC, null)); // 5. Create an object attribute for the `Accounts`. long accountsID = graph.createNode(new Node(rand.nextLong(), \"Accounts\", OA, null)); // 6. Create the `Teller` and `Auditor` user attributes. long tellerID = graph.createNode(new Node(rand.nextLong(), \"Teller\", UA, null)); long auditorID = graph.createNode(new Node(rand.nextLong(), \"Auditor\", UA, null)); // 7. Assign the `Accounts` object attribute to the `RBAC` policy class node. graph.assign(new Node(accountsID, OA), new Node(rbacID, PC)); // 8. Assign the object, `o1`, to the `Accounts` object attribute. graph.assign(new Node(objectID, O), new Node(accountsID, OA)); // 9. Assign `u1` to the `Teller` user attribute and `u2` to the `Auditor` user attribute. graph.assign(new Node(user1ID, U), new Node(tellerID, UA)); graph.assign(new Node(user2ID, U), new Node(auditorID, UA)); // 10. Create the associations for `Teller` and `Auditor` on `Account` in RBAC. `Teller` has read and write permissions, while `Auditor` just has read permissions. graph.associate(new Node(tellerID, UA), new Node(accountsID, OA), new HashSet<>(Arrays.asList(\"r\", \"w\"))); graph.associate(new Node(auditorID, UA), new Node(accountsID, OA), new HashSet<>(Arrays.asList(\"r\"))); // 11. Create the `Branches` policy class. long branchesID = graph.createNode(new Node(rand.nextLong(), \"branches\", PC, null)); // 12. Create an object attribute for `Branch 1`. long branch1OAID = graph.createNode(new Node(rand.nextLong(), \"branch 1\", OA, null)); // 13. Assign the branch 1 OA to the branches PC graph.assign(new Node(branch1OAID, OA), new Node(branchesID, PC)); // 14. Create the `Branch 1` user attribute long branches1UAID = graph.createNode(new Node(rand.nextLong(), \"branch 1\", UA, null)); // 15. Assign the object, `o1`, to the `Branch 1` object attribute graph.assign(new Node(objectID, O), new Node(branch1OAID, OA)); // 16. Assign the users, `u1` and `u2`, to the branch 1 user attribute graph.assign(new Node(user1ID, U), new Node(branches1UAID, UA)); graph.assign(new Node(user2ID, U), new Node(branches1UAID, UA)); // 17. Create an association between the `branch 1` user attribute and the `branch 1` object attribute. //This will give both users read and write on `o1` under the `branches` policy class. graph.associate(new Node(branches1UAID, UA), new Node(branch1OAID, OA), new HashSet<>(Arrays.asList(\"r\", \"w\"))); // 18. Test the configuration using the `PReviewDecider` implementation of the `Decider` interface. //The constructor for a `PReviewDecider` receives the graph we created and a list of prohibitions. //Since no prohibitions are used in this example, we'll pass null. Decider decider = new PReviewDecider(graph, null); // 19. Check that `u1` has read and write permissions on `o1`. Set<String> permissions = decider.listPermissions(user1ID, 0, objectID); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); // 20. Check that `u1` has read permissions on `o1`. permissions = decider.listPermissions(user2ID, 0, objectID); assertTrue(permissions.contains(\"r\"));","title":"Code Wakthrough"},{"location":"policy-machine-core/#visualization","text":"Below is a visual representation of the graph created in the bank teller example.","title":"Visualization"},{"location":"policy-machine-core/#employee-record","text":"","title":"Employee Record"},{"location":"policy-machine-core/#example-configuration-summary","text":"One policy class Users: bob, alice, charlie The objects are bob's and alice's name, salary, and ssn. All users are assigned to the Staff user attribute The Staff user attribute has read permissions on Public Info, which in this case is names. Charlie has the HR attribute HR has read and write permissions on Salaries and SSNs Bob and Alice have the Grp1Mgr and Grp2Mgr attributes, respectively Grp1Mgr and Grp2Mgr have read permissions on Grp1Salaries and Grp2Salaries, respectively Bob and Alice have read and write permissions on their name and ssn, and read permissions on their salaries.","title":"Example configuration summary"},{"location":"policy-machine-core/#access-control-state_1","text":"Alice can read and write her name and SSN, and read her salary, and the salaries of those in Group 2. Bob can read and write his name and SSN, and read his salary, and salaries of those in Group 1. Charlie can read and write all salaries and SSNs, and read all names. Graph graph = new MemGraph(); // create nodes // object attributes long salariesID = graph.createNode(new Node(rand.nextLong(), \"Salaries\", OA, null)); long ssnsID = graph.createNode(new Node(rand.nextLong(), \"SSNs\", OA, null)); long grp1SalariesID = graph.createNode(new Node(rand.nextLong(), \"Grp1 Salaries\", OA, null)); long grp2SalariesID = graph.createNode(new Node(rand.nextLong(), \"Grp2 Salaries\", OA, null)); long publicID = graph.createNode(new Node(rand.nextLong(), \"Public Info\", OA, null)); long bobRecID = graph.createNode(new Node(rand.nextLong(), \"Bob Record\", OA, null)); long bobRID = graph.createNode(new Node(rand.nextLong(), \"Bob r\", OA, null)); long bobRWID = graph.createNode(new Node(rand.nextLong(), \"Bob r/w\", OA, null)); long aliceRecID = graph.createNode(new Node(rand.nextLong(), \"Alice Record\", OA, null)); long aliceRID = graph.createNode(new Node(rand.nextLong(), \"Alice r\", OA, null)); long aliceRWID = graph.createNode(new Node(rand.nextLong(), \"Alice r/w\", OA, null)); // objects for bob's name, salary, and ssn long bobNameID = graph.createNode(new Node(rand.nextLong(), \"bob name\", O, null)); long bobSalaryID = graph.createNode(new Node(rand.nextLong(), \"bob salary\", O, null)); long bobSSNID = graph.createNode(new Node(rand.nextLong(), \"bob ssn\", O, null)); // objects for alice's name, salary, and ssn long aliceNameID = graph.createNode(new Node(rand.nextLong(), \"alice name\", O, null)); long aliceSalaryID = graph.createNode(new Node(rand.nextLong(), \"alice salary\", O, null)); long aliceSSNID = graph.createNode(new Node(rand.nextLong(), \"alice ssn\", O, null)); // user attributes long hrID = graph.createNode(new Node(rand.nextLong(), \"HR\", UA, null)); long grp1MgrID = graph.createNode(new Node(rand.nextLong(), \"Grp1Mgr\", UA, null)); long grp2MgrID = graph.createNode(new Node(rand.nextLong(), \"Grp2Mgr\", UA, null)); long staffID = graph.createNode(new Node(rand.nextLong(), \"Staff\", UA, null)); long bobUAID = graph.createNode(new Node(rand.nextLong(), \"Bob\", UA, null)); long aliceUAID = graph.createNode(new Node(rand.nextLong(), \"Alice\", UA, null)); // users long bobID = graph.createNode(new Node(rand.nextLong(), \"bob\", U, null)); long aliceID = graph.createNode(new Node(rand.nextLong(), \"alice\", U, null)); long charlieID = graph.createNode(new Node(rand.nextLong(), \"charlie\", U, null)); // policy class long pcID = graph.createNode(new Node(rand.nextLong(), \"Employee Records\", PC, null)); // assignments // assign users to user attributes graph.assign(new Node(charlieID, U), new Node(hrID, UA)); graph.assign(new Node(bobID, U), new Node(grp1MgrID, UA)); graph.assign(new Node(aliceID, U), new Node(grp2MgrID, UA)); graph.assign(new Node(charlieID, U), new Node(staffID, UA)); graph.assign(new Node(bobID, U), new Node(staffID, UA)); graph.assign(new Node(aliceID, U), new Node(staffID, UA)); graph.assign(new Node(bobID, U), new Node(bobUAID, UA)); graph.assign(new Node(aliceID, U), new Node(aliceUAID, UA)); // assign objects to object attributes // salary objects graph.assign(new Node(bobSalaryID, O), new Node(salariesID, OA)); graph.assign(new Node(bobSalaryID, O), new Node(grp1SalariesID, OA)); graph.assign(new Node(bobSalaryID, O), new Node(bobRID, OA)); graph.assign(new Node(aliceSalaryID, O), new Node(salariesID, OA)); graph.assign(new Node(aliceSalaryID, O), new Node(grp2SalariesID, OA)); graph.assign(new Node(aliceSalaryID, O), new Node(aliceRID, OA)); // ssn objects graph.assign(new Node(bobSSNID, O), new Node(ssnsID, OA)); graph.assign(new Node(bobSSNID, O), new Node(bobRWID, OA)); graph.assign(new Node(aliceSSNID, O), new Node(aliceID, OA)); graph.assign(new Node(aliceSSNID, O), new Node(aliceRWID, OA)); // name objects graph.assign(new Node(bobNameID, O), new Node(publicID, OA)); graph.assign(new Node(bobNameID, O), new Node(bobRWID, OA)); graph.assign(new Node(aliceNameID, O), new Node(publicID, OA)); graph.assign(new Node(aliceNameID, O), new Node(aliceRWID, OA)); // bob and alice r/w containers to their records graph.assign(new Node(bobRID, OA), new Node(bobRecID, OA)); graph.assign(new Node(bobRWID, OA), new Node(bobRecID, OA)); graph.assign(new Node(aliceRID, OA), new Node(aliceRecID, OA)); graph.assign(new Node(aliceRWID, OA), new Node(aliceRecID, OA)); // assign object attributes to policy classes graph.assign(new Node(salariesID, OA), new Node(pcID, PC)); graph.assign(new Node(ssnsID, OA), new Node(pcID, PC)); graph.assign(new Node(grp1SalariesID, OA), new Node(pcID, PC)); graph.assign(new Node(grp2SalariesID, OA), new Node(pcID, PC)); graph.assign(new Node(publicID, OA), new Node(pcID, PC)); graph.assign(new Node(bobRecID, OA), new Node(pcID, PC)); graph.assign(new Node(aliceRecID, OA), new Node(pcID, PC)); // associations Set<String> rw = new HashSet<>(Arrays.asList(\"r\", \"w\")); Set<String> r = new HashSet<>(Arrays.asList(\"r\")); graph.associate(new Node(hrID, UA), new Node(salariesID, OA), rw); graph.associate(new Node(hrID, UA), new Node(ssnsID, OA), rw); graph.associate(new Node(grp1MgrID, UA), new Node(grp1SalariesID, OA), r); graph.associate(new Node(grp2MgrID, UA), new Node(grp2SalariesID, OA), r); graph.associate(new Node(staffID, UA), new Node(publicID, OA), r); graph.associate(new Node(bobUAID, UA), new Node(bobRWID, OA), rw); graph.associate(new Node(bobUAID, UA), new Node(bobRID, OA), r); graph.associate(new Node(aliceUAID, UA), new Node(aliceRWID, OA), rw); graph.associate(new Node(aliceUAID, UA), new Node(aliceRID, OA), r); // test configuration // create a decider // not using prohibitions in this example, so null is passed Decider decider = new PReviewDecider(graph, null); // user: bob // target: 'bob ssn' // expected: [r, w] // actual: [r, w] Set<String> permissions = decider.listPermissions(bobID, 0, bobSSNID); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); // user: bob // target: 'bob ssn' // expected: [r] // actual: [r] permissions = decider.listPermissions(bobID, 0, bobSalaryID); assertTrue(permissions.contains(\"r\")); // user: bob // target: 'alice ssn' // expected: [] // actual: [] permissions = decider.listPermissions(bobID, 0, aliceSSNID); assertTrue(permissions.isEmpty()); // user: bob // target: 'alice salary' // expected: [] // actual: [] permissions = decider.listPermissions(bobID, 0, aliceSalaryID); assertTrue(permissions.isEmpty()); // user: bob // target: 'bob ssn' // expected: [r, w] // actual: [r, w] permissions = decider.listPermissions(aliceID, 0, aliceSSNID); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); // user: charlie // target: 'alice salary' // expected: [r, w] // actual: [r, w] permissions = decider.listPermissions(charlieID, 0, aliceSalaryID); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\"));","title":"Access control state"},{"location":"policy-machine-core/#visualization_1","text":"Below is a visual representation of the graph created in the employee record example.","title":"Visualization"},{"location":"policy-machine/","text":"Policy-Machine Purpose The Policy Machine REST API exposes a standard set of administrative NGAC commands. This API also acts as a Policy Enforcement Point (PEP) by ensuring any calling user has permission to carry out a command before any action is taken. Exposing the PEP allows users to create web-based, NGAC aware applications. Important Notes Namespaces - Node's can belong to namespaces which allow for multiple nodes of the same type to have the same name. Nodes that have the same name but different type are allowed in the same namesapce. If a node is created with out specifying the namespace, it will be put in the 'default' namespace. Super user metadata - There are 7 nodes that make up the super user metadata. The super user is assigned to 2 user attributes super_ua1 and super_ua2. These two attributes are assigned to a policy class also called super. Super_ua1 is associated with an Object Attribute, super_oa1, which is also assigned to the policy class super, with * permissions. This gives any user in super_ua1 all permissions on objects in super_oa1. There is one Object called super assigned to super_oa1. Super_ua2 is associated with super_ua1 with * permissions. This allows the super user to have all permissions on itself as well. Creating a policy class - When creating a policy class we check if the requesting user has the permission \"create a policy class\" on the super object. policy class assignments - When a policy class is created, an Object Attribute that will represent the policy class is also created, and assigned to super_oa1. The representative will be used any time a user is assigning to or deassigning from the policy class. This allows us to control who can perform these actions since policy classes them selves cannot be assigned or associated to any other nodes. Getting Started Run Docker Compose Build the war file by running mvn clean package install from the project root. This will create pm.war in the project's /target/ directory. Run docker-compose up from the project root to start the docker container. Docker Compose File version: '3' services: neo4j: image: neo4j:latest volumes: - $HOME/neo4j/data:/data - $HOME/neo4j/logs:/logs ports: - 7474:7474 - 7687:7687 pm: image: tomcat:8-jre8 volumes: - ./target/pm.war:/usr/local/tomcat/webapps/pm.war ports: - 8080:8080 links: - neo4j The Compose file creates two linked containers. A Neo4j container which is where we will store our access control policy data. We expose the ports 7474 and 7687 to interact with the Neo4j database. The tomcat server that will deploy pm.war . Tested Operating Systems macOS Docker for Mac Windows 7 Docker Toolbox Note : Docker Toolbox is legacy software and handles volumes differently than Docker for Windows/Mac. There is one line in the Docker Compose file that needs to be updated. Create a shared folder in Oracle VirtualBox called /target/ which points to the target folder of the PM project. change this line in the Compose file: ./target/pm.war:/usr/local/tomcat/webapps/pm.war to //target/pm.war:/usr/local/tomcat/webapps/pm.war Connecting to a Database Upon starting the server for the first time, you must provide the database connection details to your desired database. Navigate to /pm/config.jsp , choose either Neo4j or Mysql and provide the connection parameters. Once the connection is set, the details will be saved locally on the server and used anytime the server restarts. Notes on Neo4j If using docker-compose to run the Policy Machine server, the web application will recognize the neo4j service by the name neo4j . Therefore, when setting the connection to the database, the host name should be neo4j . Also, the bolt protocol is used so the port should be 7687 . How to Use the API Requests The exposed web services act as an administrative Policy Enforcement Point (PEP). When a request comes in the PEP forwards the request to the PDP, which ensures the requesting user is allowed to carry out the action. This means the PEP always needs to know which user is sending a request. This is tracked using session IDs that represent users who have authenticated successfully with the server. Every endpoint requires this session ID to determine the user. The only API that does not require a session ID is the Sessions API. This API is used to authenticate users and provides the session IDs that will be used in subsequent requests to the Policy Machine. For example, to sign in as the super user: POST /pm/api/sessions Content-Type:application/json { \"username\": \"super\", \"password\": \"super\" } The response from the server will look like: { \"code\": 9000, \"message\": \"success\", \"entity\": \"NEW_SESSION_ID\" } Now the user can pass this session ID to the server for any other calls to the API. Responses A response from the Policy Machine will always return an HTTP status code of 200, with more details provided in the body of the response. For example: { \"code\": 9000, \"message\": \"success\", \"entity\": \"return value of the API call\" } Response codes code type description 9000 success the request was successful 6001 error assignment does not exist 6002 error prohibition name already exists 6003 error node is already assigned to the prohibition 6004 error an ID was expected but none was provided 6005 error assignment already exists 6006 error not a valid property 6007 error invalid prohibition subject type 6008 error node not found 6009 error no user provided 6010 error association does not exist 6011 error null name 6012 error node in prohibition does not exist 6013 error no subject was provided 6014 error configuration error 6015 error property not found 6016 error node name not in namespace 6017 error a node already exists with the provided name 6018 error invalid node type 6019 error the subject of the prohibition does not exist 6020 error null type 6021 error a node already exists with the name in the namesapce 6022 error prohibition does not exist 6023 error session does not exist 6024 error access denied 6025 error a node with the given ID already exists 6026 error association already exists 6027 error missing permissions 6028 error session user not found 6029 error unexpected number of nodes returned 6030 error invalid assignment 6031 error no base ID 6032 error no process ID 6034 error invalid association 6035 error node exists 6036 error a policy name with the given name already exists 6037 error invalid credentials 6038 error loading exception 6039 error null node context provided 6041 error not implemented 6042 error error loading database configuration 6043 error error hashing user password 6044 error null operations 6045 error authentication error 6046 error null session ID 6047 error policy class has no rep node 7000 error database error Sessions API Create session Authenticate the provided credentials and return a session ID if successfully authenticated. Endpoint POST /pm/api/sessions Parameters Parameter Required Location Description username required body The username of the user password required body The password of the user Example request $ curl -X POST {host}:{port}/pm/api/sessions Example request body { \"username\": \"super\", \"password\": \"super\" } Example response { \"code\": 9000, \"message\": \"success\", \"entity\": \"{sessionID}\" } Delete session Delete the session with the given session ID. Endpoint DELETE /pm/api/sessions/{sessionID} Example request $ curl -X DELETE {host}:{port}/pm/api/sessions/{sessionID} Example response { \"code\": 9000, \"message\": \"session deleted\", \"entity\": \"null\" } Get session user Get the ID of the user that corresponds with the provided session ID. Endpoint GET /pm/api/sessions/{sessionID} Example request $ curl {host}:{port}/pm/api/sessions/{sessionID} Example response { \"code\": 9000, \"message\": \"success\", \"entity\": 1234 } Graph API Get nodes Retrieve nodes from the graph. Use query parameters to filter nodes based on name, type, or any other properties nodes may have. The returned set of nodes will only contain those the user, identified by the session parameter, has access to. Endpoint GET /pm/api/graph/nodes Parameters Parameter Required Location Description session true query The ID of the current session. name false query The name of the nodes to search for. type false query The type of the nodes to search for. Important Notes The name and type query parameters are the only preset parameters to search for. It is possible to search for nodes with any property key value pair by including the pair in the query parameters of the request. For example, ?key1=value1&key2=value2 . Only nodes that match every provided property will be returned. To search for all nodes that have a specfic property key but an arbitrary value use the wildcard * . For example, key3=* . Example request $ curl {host}:{port}/pm/api/graph/nodes?session={sessionID}&type=OA Example response { \"code\": 9000, \"message\": \"success\", \"entity\": [ { \"name\": \"node1\", \"type\": \"OA\", \"properties\": { \"key1\": \"value1\" } }, { \"name\": \"node2\", \"type\": \"OA\", \"properties\": { \"key2\": \"value2\" } } ] } Create node Create a new node in the NGAC graph with the provided name, type, and properties. When creating a policy class, leave the baseID parameter empty, as it will be ignored. For all other node type, a base ID is required in order to connect the node to the graph and ensure the calling user (identified by the provided session ID) has the permission to create a node in the base node (check that the user can assign to the base node). Endpoint POST /pm/api/graph/nodes Parameters Parameter Required Location Description session true query The ID of the current session. parentID false body The ID of the node to assign the new node to. name true body The name of the node. type true body The type of the node. properties true body A map of properties to give the node. Example request $ curl -X POST {host}:{port}/pm/api/graph/nodes?session={sessionID} Example request body { \"name\": \"newNode\", \"type\": \"OA\", \"properties\": { \"key1\": \"value1\", \"key2\": \"value2\" } } Example response { \"code\": 9000, \"message\": \"success\", \"entity\": 12345 } Get node Retrieve the information for a node identified by the given ID. Endpoint GET /pm/api/graph/nodes/{nodeID} Parameters Parameter Required Location Description session true query The ID of the current session. nodeID true path The ID of the node to retrieve. Example request $ curl {host}:{port}/pm/api/graph/nodes/12345678?session={sessionID} Example response { \"code\": 9000, \"message\": \"success\", \"entity\": { \"id\": 12345678, \"name\": \"newNode\", \"type\": \"OA\", \"properties\": { \"key1\": \"value1\", \"key2\": \"value2\" } } } Update node Update the name and/or properties of a node with the given ID. The properties provided in the parameters will overwrite existing properties. Endpoint UPDATE /pm/api/graph/nodes/{nodeID} Parameters Parameter Required Location Description session true query The ID of the current session. nodeID true path The ID of the node to update. name false body The updated name. properties false body The properties to override the existing properties of the node. Example request $ curl -X PUT {host}:{port}/pm/api/graph/nodes/12345?session={sessionID} Example request body { \"name\": \"updated_name\", \"properties\": { \"key3\": \"value3\" } } Example response { \"code\": 9000, \"message\": \"node updated\", \"entity\": null } Delete node Delete the node with the given ID. The calling user must have permission to delete the node in order for the action to successfully be carried out. Endpoint DELETE /pm/api/graph/nodes/{nodeID} Parameters Parameter Required Location Description session true query The ID of the current session. nodeID true path The ID of the node to delete. Example request $ curl -X DELETE {host}:{port}/pm/api/graph/nodes/12345?session={sessionID} Example response { \"code\": 9000, \"message\": \"node deleted\", \"entity\": null } Get node children Get the nodes that are assigned to the node with the given ID. The method will return only the children the calling user has access to. Endpoint GET /pm/api/graph/nodes/{nodeID}/children Parameters Parameter Required Location Description session true query The ID of the current session. nodeID true path The ID of the node to get the children of. Example request $ curl {host}:{port}/pm/api/graph/nodes/{nodeID}/children?session={sessionID} Example response { \"code\": 9000, \"message\": \"success\", \"entity\": [ { \"name\": \"child1\", \"type\": \"OA\", \"properties\": { \"key1\": \"value1\" } }, { \"name\": \"child2\", \"type\": \"OA\", \"properties\": { \"key2\": \"value2\" } } ] } Get node parents Get the nodes that a node is assigned to. Only the parents that the calling user has access to will be returned. Endpoint GET /pm/api/graph/nodes/{nodeID}/parents Parameters Parameter Required Location Description session true query The ID of the current session. nodeID true path The ID of the node to get the parents of. Example request $ curl {host}:{port}/pm/api/graph/nodes/1234/parents?session={sessionID} Example response { \"code\": 9000, \"message\": \"success\", \"entity\": [ { \"name\": \"parent1\", \"type\": \"OA\", \"properties\": { \"key1\": \"value1\" } }, { \"name\": \"parent2\", \"type\": \"OA\", \"properties\": { \"key2\": \"value2\" } } ] } Create assignment Create an assignment between two nodes. An assignment must not already exist between the nodes, and the types of the nodes must make a valid assignment. child parent PC OA OA, PC UA UA, PC O OA u UA Endpoint POST /pm/api/graph/{child}/assignments/{parent} Parameters Parameter Required Location Description session true query The ID of the current session. child true path The ID of the child node and a matrix parameter for the type. parent true path The ID of the parent node and a matrix parameter for the type. Example request $ curl -X POST {host}:{port}/pm/api/graph/child;id=1234;type=OA/assignments/parent;id=4321;type=OA?session={sessionID} Example response { \"code\": 9000, \"message\": \"assignment created\", \"entity\": null } Delete assignment Delete an assignment between two nodes, as long as the calling user has permissions to do so. If an assignment does not exist between the two nodes, nothing will happen and a success code will be returned. Endpoint DELETE /pm/api/graph/{childID}/assignments/{parentID} Parameters Parameter Required Location Description session true query The ID of the current session. child true body The ID of the child node and a martix parameter for the type. parent true body The ID of the parent node and a matrix parameter for the type. Example request $ curl -X DELETE {host}:{port}/pm/api/graph/child;id=1234;type=OA/assignments/parent;id=4321;type=OA?session={sessionID} Example response { \"code\": 9000, \"message\": \"assignment deleted\", \"entity\": null } Get associations Get the associations the given node is apart of. The node must exist in the graph. The query parameter type is required and denotes which type of associations to retrieve for the node. Accepted values are source and target . Source will get the associations the given node is the source of. Target will get the associations the given node is a target of. Endpoint GET /pm/api/graph/{nodeID}/associations Parameters Parameter Required Location Description session true query The ID of the current session. nodeID true path The ID of the node to get the associations for. type true query Either source or target . Example request $ curl {host}:{port}/pm/api/graph/101?session={sessionID}&type=source Example response { \"1234\": [ \"read\", \"write\" ], \"4321\": [ \"read\" ] } Create association Create an association between a user attribute and a target node. The user attribute and target nodes need to already exist in the graph. The target node can be another user attribute or an object attribute. The target segment of the request url must contain the ID and type of the intended target node. Endpoint POST /pm/api/graph/{uaID}/associations/{target} Parameters Parameter Required Location Description session true query The ID of the current session. uaID true path The ID of the user attribute. target true path The target of the association. The ID and Type are required matrix parameters. operations false body The set of operations to give the association. Example request $ curl {host}:{port}/pm/api/graph/1234/associations/target;id=4321;type=OA?session={sessionID} Example request body { \"operations\": [ \"read\", \"write\" ] } Example response { \"code\": 9000, \"message\": \"association created\", \"entity\": null } Update association Update an association between a user attribute and a target node. The existing operations will be overwritten by the operations provided in the request. If an association does not exist between the two nodes, one will be created. Endpoint PUT /pm/api/graph/{uaID}/associations/{target} Parameters Parameter Required Location Description session true query The ID of the current session. uaID true path The ID of the user attribute. target true path The target of the association. The ID and Type are required matrix parameters. operations false body The set of operations to give the association. Example request $ curl -X PUT {host}:{port}/pm/api/graph/1234/associations/target;id=4321;type=OA?session={sessionID} Example request body { \"operations\": [ \"read\" ] } Example response { \"code\": 9000, \"message\": \"association updated\", \"entity\": null } Delete association Delete an association between two nodes. If one does not exist, nothing will happen, and a success code will be returned. Endpoint DELETE /pm/api/graph/{uaID}/associations/{target} Parameters Parameter Required Location Description session true query The ID of the current session. uaID true path The ID of the user attribute. target true path The target of the association. The ID and Type are required matrix parameters. Example request $ curl -X DELETE {host}:{port}/pm/api/graph/1234/associations/target;id=4321;type=OA?session={sessionID} Example response { \"code\": 9000, \"message\": \"association deleted\", \"entity\": null }","title":"Policy-Machine"},{"location":"policy-machine/#policy-machine","text":"","title":"Policy-Machine"},{"location":"policy-machine/#purpose","text":"The Policy Machine REST API exposes a standard set of administrative NGAC commands. This API also acts as a Policy Enforcement Point (PEP) by ensuring any calling user has permission to carry out a command before any action is taken. Exposing the PEP allows users to create web-based, NGAC aware applications.","title":"Purpose"},{"location":"policy-machine/#important-notes","text":"Namespaces - Node's can belong to namespaces which allow for multiple nodes of the same type to have the same name. Nodes that have the same name but different type are allowed in the same namesapce. If a node is created with out specifying the namespace, it will be put in the 'default' namespace. Super user metadata - There are 7 nodes that make up the super user metadata. The super user is assigned to 2 user attributes super_ua1 and super_ua2. These two attributes are assigned to a policy class also called super. Super_ua1 is associated with an Object Attribute, super_oa1, which is also assigned to the policy class super, with * permissions. This gives any user in super_ua1 all permissions on objects in super_oa1. There is one Object called super assigned to super_oa1. Super_ua2 is associated with super_ua1 with * permissions. This allows the super user to have all permissions on itself as well. Creating a policy class - When creating a policy class we check if the requesting user has the permission \"create a policy class\" on the super object. policy class assignments - When a policy class is created, an Object Attribute that will represent the policy class is also created, and assigned to super_oa1. The representative will be used any time a user is assigning to or deassigning from the policy class. This allows us to control who can perform these actions since policy classes them selves cannot be assigned or associated to any other nodes.","title":"Important Notes"},{"location":"policy-machine/#getting-started","text":"","title":"Getting Started"},{"location":"policy-machine/#run-docker-compose","text":"Build the war file by running mvn clean package install from the project root. This will create pm.war in the project's /target/ directory. Run docker-compose up from the project root to start the docker container.","title":"Run Docker Compose"},{"location":"policy-machine/#docker-compose-file","text":"version: '3' services: neo4j: image: neo4j:latest volumes: - $HOME/neo4j/data:/data - $HOME/neo4j/logs:/logs ports: - 7474:7474 - 7687:7687 pm: image: tomcat:8-jre8 volumes: - ./target/pm.war:/usr/local/tomcat/webapps/pm.war ports: - 8080:8080 links: - neo4j The Compose file creates two linked containers. A Neo4j container which is where we will store our access control policy data. We expose the ports 7474 and 7687 to interact with the Neo4j database. The tomcat server that will deploy pm.war .","title":"Docker Compose File"},{"location":"policy-machine/#tested-operating-systems","text":"macOS Docker for Mac Windows 7 Docker Toolbox Note : Docker Toolbox is legacy software and handles volumes differently than Docker for Windows/Mac. There is one line in the Docker Compose file that needs to be updated. Create a shared folder in Oracle VirtualBox called /target/ which points to the target folder of the PM project. change this line in the Compose file: ./target/pm.war:/usr/local/tomcat/webapps/pm.war to //target/pm.war:/usr/local/tomcat/webapps/pm.war","title":"Tested Operating Systems"},{"location":"policy-machine/#connecting-to-a-database","text":"Upon starting the server for the first time, you must provide the database connection details to your desired database. Navigate to /pm/config.jsp , choose either Neo4j or Mysql and provide the connection parameters. Once the connection is set, the details will be saved locally on the server and used anytime the server restarts.","title":"Connecting to a Database"},{"location":"policy-machine/#notes-on-neo4j","text":"If using docker-compose to run the Policy Machine server, the web application will recognize the neo4j service by the name neo4j . Therefore, when setting the connection to the database, the host name should be neo4j . Also, the bolt protocol is used so the port should be 7687 .","title":"Notes on Neo4j"},{"location":"policy-machine/#how-to-use-the-api","text":"","title":"How to Use the API"},{"location":"policy-machine/#requests","text":"The exposed web services act as an administrative Policy Enforcement Point (PEP). When a request comes in the PEP forwards the request to the PDP, which ensures the requesting user is allowed to carry out the action. This means the PEP always needs to know which user is sending a request. This is tracked using session IDs that represent users who have authenticated successfully with the server. Every endpoint requires this session ID to determine the user. The only API that does not require a session ID is the Sessions API. This API is used to authenticate users and provides the session IDs that will be used in subsequent requests to the Policy Machine. For example, to sign in as the super user: POST /pm/api/sessions Content-Type:application/json { \"username\": \"super\", \"password\": \"super\" } The response from the server will look like: { \"code\": 9000, \"message\": \"success\", \"entity\": \"NEW_SESSION_ID\" } Now the user can pass this session ID to the server for any other calls to the API.","title":"Requests"},{"location":"policy-machine/#responses","text":"A response from the Policy Machine will always return an HTTP status code of 200, with more details provided in the body of the response. For example: { \"code\": 9000, \"message\": \"success\", \"entity\": \"return value of the API call\" }","title":"Responses"},{"location":"policy-machine/#response-codes","text":"code type description 9000 success the request was successful 6001 error assignment does not exist 6002 error prohibition name already exists 6003 error node is already assigned to the prohibition 6004 error an ID was expected but none was provided 6005 error assignment already exists 6006 error not a valid property 6007 error invalid prohibition subject type 6008 error node not found 6009 error no user provided 6010 error association does not exist 6011 error null name 6012 error node in prohibition does not exist 6013 error no subject was provided 6014 error configuration error 6015 error property not found 6016 error node name not in namespace 6017 error a node already exists with the provided name 6018 error invalid node type 6019 error the subject of the prohibition does not exist 6020 error null type 6021 error a node already exists with the name in the namesapce 6022 error prohibition does not exist 6023 error session does not exist 6024 error access denied 6025 error a node with the given ID already exists 6026 error association already exists 6027 error missing permissions 6028 error session user not found 6029 error unexpected number of nodes returned 6030 error invalid assignment 6031 error no base ID 6032 error no process ID 6034 error invalid association 6035 error node exists 6036 error a policy name with the given name already exists 6037 error invalid credentials 6038 error loading exception 6039 error null node context provided 6041 error not implemented 6042 error error loading database configuration 6043 error error hashing user password 6044 error null operations 6045 error authentication error 6046 error null session ID 6047 error policy class has no rep node 7000 error database error","title":"Response codes"},{"location":"policy-machine/#sessions-api","text":"","title":"Sessions API"},{"location":"policy-machine/#create-session","text":"Authenticate the provided credentials and return a session ID if successfully authenticated.","title":"Create session"},{"location":"policy-machine/#endpoint","text":"POST /pm/api/sessions","title":"Endpoint"},{"location":"policy-machine/#parameters","text":"Parameter Required Location Description username required body The username of the user password required body The password of the user","title":"Parameters"},{"location":"policy-machine/#example-request","text":"$ curl -X POST {host}:{port}/pm/api/sessions","title":"Example request"},{"location":"policy-machine/#example-request-body","text":"{ \"username\": \"super\", \"password\": \"super\" }","title":"Example request body"},{"location":"policy-machine/#example-response","text":"{ \"code\": 9000, \"message\": \"success\", \"entity\": \"{sessionID}\" }","title":"Example response"},{"location":"policy-machine/#delete-session","text":"Delete the session with the given session ID.","title":"Delete session"},{"location":"policy-machine/#endpoint_1","text":"DELETE /pm/api/sessions/{sessionID}","title":"Endpoint"},{"location":"policy-machine/#example-request_1","text":"$ curl -X DELETE {host}:{port}/pm/api/sessions/{sessionID}","title":"Example request"},{"location":"policy-machine/#example-response_1","text":"{ \"code\": 9000, \"message\": \"session deleted\", \"entity\": \"null\" }","title":"Example response"},{"location":"policy-machine/#get-session-user","text":"Get the ID of the user that corresponds with the provided session ID.","title":"Get session user"},{"location":"policy-machine/#endpoint_2","text":"GET /pm/api/sessions/{sessionID}","title":"Endpoint"},{"location":"policy-machine/#example-request_2","text":"$ curl {host}:{port}/pm/api/sessions/{sessionID}","title":"Example request"},{"location":"policy-machine/#example-response_2","text":"{ \"code\": 9000, \"message\": \"success\", \"entity\": 1234 }","title":"Example response"},{"location":"policy-machine/#graph-api","text":"","title":"Graph API"},{"location":"policy-machine/#get-nodes","text":"Retrieve nodes from the graph. Use query parameters to filter nodes based on name, type, or any other properties nodes may have. The returned set of nodes will only contain those the user, identified by the session parameter, has access to.","title":"Get nodes"},{"location":"policy-machine/#endpoint_3","text":"GET /pm/api/graph/nodes","title":"Endpoint"},{"location":"policy-machine/#parameters_1","text":"Parameter Required Location Description session true query The ID of the current session. name false query The name of the nodes to search for. type false query The type of the nodes to search for. Important Notes The name and type query parameters are the only preset parameters to search for. It is possible to search for nodes with any property key value pair by including the pair in the query parameters of the request. For example, ?key1=value1&key2=value2 . Only nodes that match every provided property will be returned. To search for all nodes that have a specfic property key but an arbitrary value use the wildcard * . For example, key3=* .","title":"Parameters"},{"location":"policy-machine/#example-request_3","text":"$ curl {host}:{port}/pm/api/graph/nodes?session={sessionID}&type=OA","title":"Example request"},{"location":"policy-machine/#example-response_3","text":"{ \"code\": 9000, \"message\": \"success\", \"entity\": [ { \"name\": \"node1\", \"type\": \"OA\", \"properties\": { \"key1\": \"value1\" } }, { \"name\": \"node2\", \"type\": \"OA\", \"properties\": { \"key2\": \"value2\" } } ] }","title":"Example response"},{"location":"policy-machine/#create-node","text":"Create a new node in the NGAC graph with the provided name, type, and properties. When creating a policy class, leave the baseID parameter empty, as it will be ignored. For all other node type, a base ID is required in order to connect the node to the graph and ensure the calling user (identified by the provided session ID) has the permission to create a node in the base node (check that the user can assign to the base node).","title":"Create node"},{"location":"policy-machine/#endpoint_4","text":"POST /pm/api/graph/nodes","title":"Endpoint"},{"location":"policy-machine/#parameters_2","text":"Parameter Required Location Description session true query The ID of the current session. parentID false body The ID of the node to assign the new node to. name true body The name of the node. type true body The type of the node. properties true body A map of properties to give the node.","title":"Parameters"},{"location":"policy-machine/#example-request_4","text":"$ curl -X POST {host}:{port}/pm/api/graph/nodes?session={sessionID}","title":"Example request"},{"location":"policy-machine/#example-request-body_1","text":"{ \"name\": \"newNode\", \"type\": \"OA\", \"properties\": { \"key1\": \"value1\", \"key2\": \"value2\" } }","title":"Example request body"},{"location":"policy-machine/#example-response_4","text":"{ \"code\": 9000, \"message\": \"success\", \"entity\": 12345 }","title":"Example response"},{"location":"policy-machine/#get-node","text":"Retrieve the information for a node identified by the given ID.","title":"Get node"},{"location":"policy-machine/#endpoint_5","text":"GET /pm/api/graph/nodes/{nodeID}","title":"Endpoint"},{"location":"policy-machine/#parameters_3","text":"Parameter Required Location Description session true query The ID of the current session. nodeID true path The ID of the node to retrieve.","title":"Parameters"},{"location":"policy-machine/#example-request_5","text":"$ curl {host}:{port}/pm/api/graph/nodes/12345678?session={sessionID}","title":"Example request"},{"location":"policy-machine/#example-response_5","text":"{ \"code\": 9000, \"message\": \"success\", \"entity\": { \"id\": 12345678, \"name\": \"newNode\", \"type\": \"OA\", \"properties\": { \"key1\": \"value1\", \"key2\": \"value2\" } } }","title":"Example response"},{"location":"policy-machine/#update-node","text":"Update the name and/or properties of a node with the given ID. The properties provided in the parameters will overwrite existing properties.","title":"Update node"},{"location":"policy-machine/#endpoint_6","text":"UPDATE /pm/api/graph/nodes/{nodeID}","title":"Endpoint"},{"location":"policy-machine/#parameters_4","text":"Parameter Required Location Description session true query The ID of the current session. nodeID true path The ID of the node to update. name false body The updated name. properties false body The properties to override the existing properties of the node.","title":"Parameters"},{"location":"policy-machine/#example-request_6","text":"$ curl -X PUT {host}:{port}/pm/api/graph/nodes/12345?session={sessionID}","title":"Example request"},{"location":"policy-machine/#example-request-body_2","text":"{ \"name\": \"updated_name\", \"properties\": { \"key3\": \"value3\" } }","title":"Example request body"},{"location":"policy-machine/#example-response_6","text":"{ \"code\": 9000, \"message\": \"node updated\", \"entity\": null }","title":"Example response"},{"location":"policy-machine/#delete-node","text":"Delete the node with the given ID. The calling user must have permission to delete the node in order for the action to successfully be carried out.","title":"Delete node"},{"location":"policy-machine/#endpoint_7","text":"DELETE /pm/api/graph/nodes/{nodeID}","title":"Endpoint"},{"location":"policy-machine/#parameters_5","text":"Parameter Required Location Description session true query The ID of the current session. nodeID true path The ID of the node to delete.","title":"Parameters"},{"location":"policy-machine/#example-request_7","text":"$ curl -X DELETE {host}:{port}/pm/api/graph/nodes/12345?session={sessionID}","title":"Example request"},{"location":"policy-machine/#example-response_7","text":"{ \"code\": 9000, \"message\": \"node deleted\", \"entity\": null }","title":"Example response"},{"location":"policy-machine/#get-node-children","text":"Get the nodes that are assigned to the node with the given ID. The method will return only the children the calling user has access to.","title":"Get node children"},{"location":"policy-machine/#endpoint_8","text":"GET /pm/api/graph/nodes/{nodeID}/children","title":"Endpoint"},{"location":"policy-machine/#parameters_6","text":"Parameter Required Location Description session true query The ID of the current session. nodeID true path The ID of the node to get the children of.","title":"Parameters"},{"location":"policy-machine/#example-request_8","text":"$ curl {host}:{port}/pm/api/graph/nodes/{nodeID}/children?session={sessionID}","title":"Example request"},{"location":"policy-machine/#example-response_8","text":"{ \"code\": 9000, \"message\": \"success\", \"entity\": [ { \"name\": \"child1\", \"type\": \"OA\", \"properties\": { \"key1\": \"value1\" } }, { \"name\": \"child2\", \"type\": \"OA\", \"properties\": { \"key2\": \"value2\" } } ] }","title":"Example response"},{"location":"policy-machine/#get-node-parents","text":"Get the nodes that a node is assigned to. Only the parents that the calling user has access to will be returned.","title":"Get node parents"},{"location":"policy-machine/#endpoint_9","text":"GET /pm/api/graph/nodes/{nodeID}/parents","title":"Endpoint"},{"location":"policy-machine/#parameters_7","text":"Parameter Required Location Description session true query The ID of the current session. nodeID true path The ID of the node to get the parents of.","title":"Parameters"},{"location":"policy-machine/#example-request_9","text":"$ curl {host}:{port}/pm/api/graph/nodes/1234/parents?session={sessionID}","title":"Example request"},{"location":"policy-machine/#example-response_9","text":"{ \"code\": 9000, \"message\": \"success\", \"entity\": [ { \"name\": \"parent1\", \"type\": \"OA\", \"properties\": { \"key1\": \"value1\" } }, { \"name\": \"parent2\", \"type\": \"OA\", \"properties\": { \"key2\": \"value2\" } } ] }","title":"Example response"},{"location":"policy-machine/#create-assignment","text":"Create an assignment between two nodes. An assignment must not already exist between the nodes, and the types of the nodes must make a valid assignment. child parent PC OA OA, PC UA UA, PC O OA u UA","title":"Create assignment"},{"location":"policy-machine/#endpoint_10","text":"POST /pm/api/graph/{child}/assignments/{parent}","title":"Endpoint"},{"location":"policy-machine/#parameters_8","text":"Parameter Required Location Description session true query The ID of the current session. child true path The ID of the child node and a matrix parameter for the type. parent true path The ID of the parent node and a matrix parameter for the type.","title":"Parameters"},{"location":"policy-machine/#example-request_10","text":"$ curl -X POST {host}:{port}/pm/api/graph/child;id=1234;type=OA/assignments/parent;id=4321;type=OA?session={sessionID}","title":"Example request"},{"location":"policy-machine/#example-response_10","text":"{ \"code\": 9000, \"message\": \"assignment created\", \"entity\": null }","title":"Example response"},{"location":"policy-machine/#delete-assignment","text":"Delete an assignment between two nodes, as long as the calling user has permissions to do so. If an assignment does not exist between the two nodes, nothing will happen and a success code will be returned.","title":"Delete assignment"},{"location":"policy-machine/#endpoint_11","text":"DELETE /pm/api/graph/{childID}/assignments/{parentID}","title":"Endpoint"},{"location":"policy-machine/#parameters_9","text":"Parameter Required Location Description session true query The ID of the current session. child true body The ID of the child node and a martix parameter for the type. parent true body The ID of the parent node and a matrix parameter for the type.","title":"Parameters"},{"location":"policy-machine/#example-request_11","text":"$ curl -X DELETE {host}:{port}/pm/api/graph/child;id=1234;type=OA/assignments/parent;id=4321;type=OA?session={sessionID}","title":"Example request"},{"location":"policy-machine/#example-response_11","text":"{ \"code\": 9000, \"message\": \"assignment deleted\", \"entity\": null }","title":"Example response"},{"location":"policy-machine/#get-associations","text":"Get the associations the given node is apart of. The node must exist in the graph. The query parameter type is required and denotes which type of associations to retrieve for the node. Accepted values are source and target . Source will get the associations the given node is the source of. Target will get the associations the given node is a target of.","title":"Get associations"},{"location":"policy-machine/#endpoint_12","text":"GET /pm/api/graph/{nodeID}/associations","title":"Endpoint"},{"location":"policy-machine/#parameters_10","text":"Parameter Required Location Description session true query The ID of the current session. nodeID true path The ID of the node to get the associations for. type true query Either source or target .","title":"Parameters"},{"location":"policy-machine/#example-request_12","text":"$ curl {host}:{port}/pm/api/graph/101?session={sessionID}&type=source","title":"Example request"},{"location":"policy-machine/#example-response_12","text":"{ \"1234\": [ \"read\", \"write\" ], \"4321\": [ \"read\" ] }","title":"Example response"},{"location":"policy-machine/#create-association","text":"Create an association between a user attribute and a target node. The user attribute and target nodes need to already exist in the graph. The target node can be another user attribute or an object attribute. The target segment of the request url must contain the ID and type of the intended target node.","title":"Create association"},{"location":"policy-machine/#endpoint_13","text":"POST /pm/api/graph/{uaID}/associations/{target}","title":"Endpoint"},{"location":"policy-machine/#parameters_11","text":"Parameter Required Location Description session true query The ID of the current session. uaID true path The ID of the user attribute. target true path The target of the association. The ID and Type are required matrix parameters. operations false body The set of operations to give the association.","title":"Parameters"},{"location":"policy-machine/#example-request_13","text":"$ curl {host}:{port}/pm/api/graph/1234/associations/target;id=4321;type=OA?session={sessionID}","title":"Example request"},{"location":"policy-machine/#example-request-body_3","text":"{ \"operations\": [ \"read\", \"write\" ] }","title":"Example request body"},{"location":"policy-machine/#example-response_13","text":"{ \"code\": 9000, \"message\": \"association created\", \"entity\": null }","title":"Example response"},{"location":"policy-machine/#update-association","text":"Update an association between a user attribute and a target node. The existing operations will be overwritten by the operations provided in the request. If an association does not exist between the two nodes, one will be created.","title":"Update association"},{"location":"policy-machine/#endpoint_14","text":"PUT /pm/api/graph/{uaID}/associations/{target}","title":"Endpoint"},{"location":"policy-machine/#parameters_12","text":"Parameter Required Location Description session true query The ID of the current session. uaID true path The ID of the user attribute. target true path The target of the association. The ID and Type are required matrix parameters. operations false body The set of operations to give the association.","title":"Parameters"},{"location":"policy-machine/#example-request_14","text":"$ curl -X PUT {host}:{port}/pm/api/graph/1234/associations/target;id=4321;type=OA?session={sessionID}","title":"Example request"},{"location":"policy-machine/#example-request-body_4","text":"{ \"operations\": [ \"read\" ] }","title":"Example request body"},{"location":"policy-machine/#example-response_14","text":"{ \"code\": 9000, \"message\": \"association updated\", \"entity\": null }","title":"Example response"},{"location":"policy-machine/#delete-association","text":"Delete an association between two nodes. If one does not exist, nothing will happen, and a success code will be returned.","title":"Delete association"},{"location":"policy-machine/#endpoint_15","text":"DELETE /pm/api/graph/{uaID}/associations/{target}","title":"Endpoint"},{"location":"policy-machine/#parameters_13","text":"Parameter Required Location Description session true query The ID of the current session. uaID true path The ID of the user attribute. target true path The target of the association. The ID and Type are required matrix parameters.","title":"Parameters"},{"location":"policy-machine/#example-request_15","text":"$ curl -X DELETE {host}:{port}/pm/api/graph/1234/associations/target;id=4321;type=OA?session={sessionID}","title":"Example request"},{"location":"policy-machine/#example-response_15","text":"{ \"code\": 9000, \"message\": \"association deleted\", \"entity\": null }","title":"Example response"}]}